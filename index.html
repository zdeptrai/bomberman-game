<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tr√≤ Ch∆°i ƒê·∫∑t Bom</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            background-color: #1a202c;
            color: #e2e8f0;
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 1000px;
            width: 100%;
        }

        #game-board {
            display: grid;
            border: 2px solid #a0aec0;
            margin-bottom: 20px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            background-color: #2d3748;
            border-radius: 8px;
        }

        .cell {
            width: 40px;
            height: 40px;
            background-color: #2d3748;
            border: 1px solid #4a5568;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .cell.wall {
            background-color: #4a5568;
            border-color: #2d3748;
        }
        .cell.destructible {
            background-color: #a78bfa;
            border: 1px solid #7c3aed;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40"><rect width="40" height="40" fill="%23a78bfa" /><path d="M0,0 L40,40 M0,40 L40,0" stroke="%237c3aed" stroke-width="2"/></svg>');
            background-size: cover;
        }
        .cell.powerup {
            background-color: #48bb78;
            position: relative;
            animation: pulse 1s infinite;
        }
        .cell.powerup.speed::before {
            content: '‚ö°Ô∏è';
            font-size: 24px;
        }
        .cell.powerup.blast::before {
            content: 'üí•';
            font-size: 24px;
        }
        .cell.explosion {
            background-color: #f56565;
            animation: explode 0.5s ease-in-out;
            border: none;
        }
        .cell.player-1 {
            background-color: #63b3ed;
            border: 2px solid #4299e1;
            border-radius: 50%;
        }
        .cell.player-2 {
            background-color: #f6ad55;
            border: 2px solid #ed8936;
            border-radius: 50%;
        }
        .cell.bomb {
            background-color: #e53e3e;
            border: 2px solid #c53030;
            position: relative;
            border-radius: 50%;
            animation: bomb-timer 1s infinite;
        }
        
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2d3748;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.7);
            z-index: 100;
            text-align: center;
            border: 2px solid #4a5568;
            display: none;
        }
        .message-box button {
            margin-top: 1rem;
            font-weight: bold;
        }
        
        @keyframes pulse {
            0% { transform: scale(0.9); }
            50% { transform: scale(1.1); }
            100% { transform: scale(0.9); }
        }
        @keyframes explode {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.8; }
            100% { transform: scale(2); opacity: 0; }
        }
        @keyframes bomb-timer {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex flex-col items-center p-4">
    <div class="container bg-gray-800 p-8 rounded-lg shadow-xl">
        <h1 class="text-4xl font-bold mb-4 text-purple-400">Tr√≤ Ch∆°i ƒê·∫∑t Bom</h1>
        <h2 class="text-lg mb-2">ID c·ªßa b·∫°n: <span id="userIdDisplay" class="font-bold text-yellow-300">ƒêang t·∫£i...</span></h2>
        
        <div id="lobby" class="flex flex-col items-center">
            <button id="createGameBtn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-full transition-colors duration-200">T·∫°o Ph√≤ng M·ªõi</button>
            <p class="my-4">ho·∫∑c</p>
            <div class="flex items-center space-x-2">
                <input type="text" id="gameIdInput" placeholder="Nh·∫≠p ID ph√≤ng" class="p-2 rounded-lg bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-purple-500">
                <button id="joinGameBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-full transition-colors duration-200">Tham Gia</button>
            </div>
        </div>
        
        <div id="game-container" class="hidden flex flex-col items-center mt-8 w-full">
            <h2 id="gameStatus" class="text-2xl font-bold mb-4 text-center">ƒêang ch·ªù ng∆∞·ªùi ch∆°i...</h2>
            
            <div class="w-full flex justify-between items-start mb-4">
                <!-- Th√¥ng tin ng∆∞·ªùi ch∆°i 1 -->
                <div id="player1Status" class="flex-1 p-3 bg-gray-700 rounded-lg mr-2">
                    <p class="font-bold text-lg text-blue-400">Ng∆∞·ªùi ch∆°i 1 (Xanh)</p>
                    <p class="text-sm">T·ªëc ƒë·ªô: <span id="player1-speed">1</span></p>
                    <p class="text-sm">Ph·∫°m vi n·ªï: <span id="player1-blast">1</span></p>
                </div>
                
                <!-- Th√¥ng tin ng∆∞·ªùi ch∆°i 2 -->
                <div id="player2Status" class="flex-1 p-3 bg-gray-700 rounded-lg ml-2">
                    <p class="font-bold text-lg text-yellow-400">Ng∆∞·ªùi ch∆°i 2 (V√†ng)</p>
                    <p class="text-sm">T·ªëc ƒë·ªô: <span id="player2-speed">1</span></p>
                    <p class="text-sm">Ph·∫°m vi n·ªï: <span id="player2-blast">1</span></p>
                </div>
            </div>

            <div id="game-board-wrapper" class="flex justify-center items-center">
                <div id="game-board"></div>
            </div>
        </div>

        <!-- H·ªôp th√¥ng b√°o t√πy ch·ªânh -->
        <div id="messageBox" class="message-box hidden">
            <h2 id="messageTitle" class="text-3xl font-bold text-purple-400"></h2>
            <p id="messageText" class="mt-2 text-lg"></p>
            <button id="messageButton" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-full">Ch∆°i l·∫°i</button>
        </div>
    </div>
    
    <script type="module">
        // Import c√°c th∆∞ vi·ªán Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithCustomToken, onAuthStateChanged, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Bi·∫øn to√†n c·ª•c t·ª´ Canvas (ƒë∆∞·ª£c cung c·∫•p t·ª± ƒë·ªông)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : '';
        
        // Kh·ªüi t·∫°o Firebase
        let app, db, auth, userId;
        const initFirebase = async () => {
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        document.getElementById('userIdDisplay').textContent = userId;
                        console.log('Firebase initialized and authenticated. User ID:', userId);
                    } else {
                        console.error("Kh√¥ng c√≥ ng∆∞·ªùi d√πng n√†o ƒëƒÉng nh·∫≠p.");
                    }
                });
            } catch (error) {
                console.error("L·ªói khi kh·ªüi t·∫°o Firebase:", error);
            }
        };

        // K√≠ch th∆∞·ªõc b·∫£n ƒë·ªì
        const MAP_SIZE = 15;
        const CELL_SIZE = 40;
        
        // Lo·∫°i √¥ tr√™n b·∫£n ƒë·ªì
        const WALL = 'W';
        const DESTRUCTIBLE = 'D';
        const EMPTY = 'E';
        const POWERUP_SPEED = 'PS';
        const POWERUP_BLAST = 'PB';
        const BOMB = 'B';
        const EXPLOSION = 'X';

        // Bi·∫øn tr·∫°ng th√°i tr√≤ ch∆°i
        let gameId = '';
        let playerNumber = 0; // S·ªë th·ª© t·ª± ng∆∞·ªùi ch∆°i (1 ho·∫∑c 2)
        let gameRef = null;
        let gameData = {};
        
        let bombSynth = new Tone.MembraneSynth().toDestination();
        let explosionSynth = new Tone.NoiseSynth({
            noise: { type: 'pink' },
            envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.05 }
        }).toDestination();
        
        // C√°c b·∫£n ƒë·ªì ƒë∆∞·ª£c t·∫°o s·∫µn
        const maps = [
            // B·∫£n ƒë·ªì 1
            [
                'W W W W W W W W W W W W W W W',
                'W E D D D D D D D D D D D D W',
                'W D W D W D W D W D W D W D W',
                'W D D D D D D D D D D D D D W',
                'W D W D W D W D W D W D W D W',
                'W D D D D D D D D D D D D D W',
                'W D W D W D W D W D W D W D W',
                'W D D D D D D D D D D D D D W',
                'W D W D W D W D W D W D W D W',
                'W D D D D D D D D D D D D D W',
                'W D W D W D W D W D W D W D W',
                'W D D D D D D D D D D D D D W',
                'W D W D W D W D W D W D W D W',
                'W D D D D D D D D D D D D D W',
                'W W W W W W W W W W W W W W W',
            ].map(row => row.split(' ')),
            // B·∫£n ƒë·ªì 2
            [
                'W W W W W W W W W W W W W W W',
                'W E D D W D D W D D W D D E W',
                'W D W D W D W D W D W D W D W',
                'W D D D D D D D D D D D D D W',
                'W W W D W D W D W D W D W W W',
                'W D D D D D D D D D D D D D W',
                'W D W D W W W D W D W D W D W',
                'W D D D D D D D D D D D D D W',
                'W D W D W D W D W D W D W D W',
                'W D D D D D D D D D D D D D W',
                'W W W D W D W D W D W D W W W',
                'W D D D D D D D D D D D D D W',
                'W D W D W D W D W D W D W D W',
                'W E D D W D D W D D W D D E W',
                'W W W W W W W W W W W W W W W',
            ].map(row => row.split(' ')),
        ];

        // V·ªã tr√≠ b·∫Øt ƒë·∫ßu c·ªßa ng∆∞·ªùi ch∆°i
        const playerStartPositions = {
            1: { x: 1, y: 1 },
            2: { x: MAP_SIZE - 2, y: MAP_SIZE - 2 }
        };

        // H√†m t·∫°o b·∫£ng game
        function createGameBoard() {
            const gameBoard = document.getElementById('game-board');
            gameBoard.innerHTML = '';
            gameBoard.style.gridTemplateColumns = `repeat(${MAP_SIZE}, ${CELL_SIZE}px)`;

            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    gameBoard.appendChild(cell);
                }
            }
        }

        // C·∫≠p nh·∫≠t giao di·ªán d·ª±a tr√™n d·ªØ li·ªáu game t·ª´ Firestore
        function updateUI() {
            const { map, players, turn, gameState } = gameData;
            
            // C·∫≠p nh·∫≠t tr·∫°ng th√°i game v√† ng∆∞·ªùi ch∆°i
            const gameStatusEl = document.getElementById('gameStatus');
            const player1Status = document.getElementById('player1-speed');
            const player1Blast = document.getElementById('player1-blast');
            const player2Status = document.getElementById('player2-speed');
            const player2Blast = document.getElementById('player2-blast');
            
            if (gameState === 'waiting') {
                gameStatusEl.textContent = "ƒêang ch·ªù ng∆∞·ªùi ch∆°i kh√°c tham gia...";
            } else if (gameState === 'playing') {
                gameStatusEl.textContent = (turn === playerNumber) ? 'ƒê·∫øn l∆∞·ª£t b·∫°n!' : 'ƒêang ch·ªù ƒë·ªëi th·ªß...';
            } else if (gameState === 'win') {
                const winner = gameData.winner;
                if (winner === playerNumber) {
                    showMessage('B·∫°n ƒê√£ Th·∫Øng!', 'Ch√∫c m·ª´ng b·∫°n ƒë√£ ƒë√°nh b·∫°i ƒë·ªëi th·ªß!');
                } else {
                    showMessage('B·∫°n ƒê√£ Thua!', 'B·∫°n ƒë√£ b·ªã ƒë·ªëi th·ªß ƒë√°nh b·∫°i.');
                }
                document.removeEventListener('keydown', handleKeydown);
                return;
            } else if (gameState === 'draw') {
                showMessage('H√≤a!', 'Kh√¥ng c√≤n ai chi·∫øn th·∫Øng.');
                document.removeEventListener('keydown', handleKeydown);
                return;
            }
            
            if (players[1]) {
                player1Status.textContent = players[1].speed;
                player1Blast.textContent = players[1].blastRange;
            } else {
                player1Status.textContent = 'ƒê√£ thua';
                player1Blast.textContent = 'ƒê√£ thua';
            }
            
            if (players[2]) {
                player2Status.textContent = players[2].speed;
                player2Blast.textContent = players[2].blastRange;
            } else {
                player2Status.textContent = 'ƒê√£ thua';
                player2Blast.textContent = 'ƒê√£ thua';
            }


            // V·∫Ω l·∫°i b·∫£n ƒë·ªì
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                    cell.className = 'cell'; // ƒê·∫∑t l·∫°i l·ªõp CSS

                    const cellType = map[y][x];
                    if (cellType === WALL) {
                        cell.classList.add('wall');
                    } else if (cellType === DESTRUCTIBLE) {
                        cell.classList.add('destructible');
                    } else if (cellType === POWERUP_SPEED) {
                        cell.classList.add('powerup', 'speed');
                    } else if (cellType === POWERUP_BLAST) {
                        cell.classList.add('powerup', 'blast');
                    } else if (cellType === BOMB) {
                        cell.classList.add('bomb');
                    } else if (cellType === EXPLOSION) {
                        cell.classList.add('explosion');
                    }

                    // V·∫Ω ng∆∞·ªùi ch∆°i
                    if (players['1'] && players['1'].x === x && players['1'].y === y) {
                        cell.classList.add('player-1');
                    }
                    if (players['2'] && players['2'].x === x && players['2'].y === y) {
                        cell.classList.add('player-2');
                    }
                }
            }
        }

        // X·ª≠ l√Ω c√°c ph√≠m di chuy·ªÉn
        async function handleKeydown(e) {
            if (gameData.gameState !== 'playing' || gameData.turn !== playerNumber) return;

            const player = gameData.players[playerNumber];
            let newPos = { ...player };
            let updated = false;

            const moveSpeed = player.speed || 1;

            switch (e.key) {
                case 'ArrowUp':
                    newPos.y -= moveSpeed;
                    updated = true;
                    break;
                case 'ArrowDown':
                    newPos.y += moveSpeed;
                    updated = true;
                    break;
                case 'ArrowLeft':
                    newPos.x -= moveSpeed;
                    updated = true;
                    break;
                case 'ArrowRight':
                    newPos.x += moveSpeed;
                    updated = true;
                    break;
                case ' ': // Ph√≠m c√°ch ƒë·ªÉ ƒë·∫∑t bom
                    placeBomb(player.x, player.y);
                    return;
            }

            if (updated) {
                if (isValidMove(newPos)) {
                    await updatePlayerPosition(newPos);
                    checkPowerup(newPos);
                    await nextTurn();
                }
            }
        }
        
        // Ki·ªÉm tra di chuy·ªÉn h·ª£p l·ªá
        function isValidMove(newPos) {
            if (newPos.x < 0 || newPos.x >= MAP_SIZE || newPos.y < 0 || newPos.y >= MAP_SIZE) {
                return false;
            }
            const cellType = gameData.map[newPos.y][newPos.x];
            return cellType === EMPTY || cellType.startsWith('P');
        }

        // Ki·ªÉm tra v√† nh·∫∑t power-up
        async function checkPowerup(pos) {
            const cellType = gameData.map[pos.y][pos.x];
            if (cellType === EMPTY || !cellType.startsWith('P')) return;

            const map = JSON.parse(JSON.stringify(gameData.map));
            map[pos.y][pos.x] = EMPTY;
            
            const players = { ...gameData.players };
            const player = players[playerNumber];
            
            if (cellType === POWERUP_SPEED) {
                player.speed = (player.speed || 1) + 1;
            } else if (cellType === POWERUP_BLAST) {
                player.blastRange = (player.blastRange || 1) + 1;
            }
            
            await setDoc(gameRef, { map, players }, { merge: true });
        }

        // C·∫≠p nh·∫≠t v·ªã tr√≠ ng∆∞·ªùi ch∆°i l√™n Firestore
        async function updatePlayerPosition(newPos) {
            const players = { ...gameData.players };
            players[playerNumber].x = newPos.x;
            players[playerNumber].y = newPos.y;
            try {
                await setDoc(gameRef, { players: players }, { merge: true });
            } catch (error) {
                console.error("L·ªói c·∫≠p nh·∫≠t v·ªã tr√≠ ng∆∞·ªùi ch∆°i:", error);
            }
        }
        
        // Chuy·ªÉn l∆∞·ª£t ch∆°i
        async function nextTurn() {
            const nextPlayer = playerNumber === 1 ? 2 : 1;
            try {
                await setDoc(gameRef, { turn: nextPlayer }, { merge: true });
            } catch (error) {
                console.error("L·ªói chuy·ªÉn l∆∞·ª£t ch∆°i:", error);
            }
        }
        
        // ƒê·∫∑t bom
        async function placeBomb(x, y) {
            const map = JSON.parse(JSON.stringify(gameData.map));
            if (map[y][x] === EMPTY) {
                bombSynth.triggerAttackRelease('C4', '8n');
                map[y][x] = BOMB;
                await setDoc(gameRef, { map: map }, { merge: true });
                
                // H·∫πn gi·ªù bom n·ªï
                setTimeout(async () => {
                    await explodeBomb(x, y);
                }, 2000);
            }
        }
        
        // Bom n·ªï
        async function explodeBomb(bombX, bombY) {
            const { map, players } = gameData;
            const blastRange = players[playerNumber].blastRange || 1;
            const newMap = JSON.parse(JSON.stringify(map));
            
            explosionSynth.triggerAttackRelease('8n');
            
            const affectedCells = [{ x: bombX, y: bombY }];
            newMap[bombY][bombX] = EXPLOSION;
            
            const directions = [{dx: 1, dy: 0}, {dx: -1, dy: 0}, {dx: 0, dy: 1}, {dx: 0, dy: -1}];
            directions.forEach(dir => {
                for (let i = 1; i <= blastRange; i++) {
                    const newX = bombX + dir.dx * i;
                    const newY = bombY + dir.dy * i;
                    
                    if (newX >= 0 && newX < MAP_SIZE && newY >= 0 && newY < MAP_SIZE) {
                        const cellType = map[newY][newX];
                        if (cellType === WALL) break;
                        
                        if (cellType === DESTRUCTIBLE) {
                            newMap[newY][newX] = Math.random() < 0.3 ? (Math.random() < 0.5 ? POWERUP_SPEED : POWERUP_BLAST) : EMPTY;
                            affectedCells.push({x: newX, y: newY});
                            break;
                        }
                        
                        newMap[newY][newX] = EXPLOSION;
                        affectedCells.push({x: newX, y: newY});
                    }
                }
            });

            await setDoc(gameRef, { map: newMap }, { merge: true });

            // Ki·ªÉm tra ng∆∞·ªùi ch∆°i b·ªã d√≠nh bom
            const playersKilled = Object.keys(players).filter(pNum => 
                affectedCells.some(cell => players[pNum] && cell.x === players[pNum].x && cell.y === players[pNum].y)
            );
            
            // X√≥a v√πng n·ªï v√† c·∫≠p nh·∫≠t tr·∫°ng th√°i ng∆∞·ªùi ch∆°i
            setTimeout(async () => {
                const finalMap = JSON.parse(JSON.stringify(gameData.map));
                affectedCells.forEach(cell => {
                    finalMap[cell.y][cell.x] = EMPTY;
                });
                
                let finalPlayers = {...gameData.players};
                playersKilled.forEach(pNum => {
                    delete finalPlayers[pNum];
                });
                
                await setDoc(gameRef, { map: finalMap, players: finalPlayers }, { merge: true });
                checkGameOver();
            }, 500);
        }
        
        // Ki·ªÉm tra ƒëi·ªÅu ki·ªán th·∫Øng/thua
        async function checkGameOver() {
            const livingPlayers = Object.keys(gameData.players);
            if (livingPlayers.length <= 1) {
                if (livingPlayers.length === 1) {
                    await setDoc(gameRef, { gameState: 'win', winner: parseInt(livingPlayers[0]) }, { merge: true });
                } else {
                    await setDoc(gameRef, { gameState: 'draw' }, { merge: true });
                }
            } else {
                await nextTurn();
            }
        }
        
        // Hi·ªÉn th·ªã th√¥ng b√°o
        function showMessage(title, text) {
            document.getElementById('messageTitle').textContent = title;
            document.getElementById('messageText').textContent = text;
            document.getElementById('messageBox').classList.remove('hidden');
        }

        // B·∫Øt ƒë·∫ßu game m·ªõi ho·∫∑c tham gia
        document.getElementById('createGameBtn').addEventListener('click', async () => {
            if (!userId) {
                console.error("User ID kh√¥ng c√≥ s·∫µn.");
                return;
            }
            gameId = userId;
            gameRef = doc(db, 'artifacts', appId, 'public/data', `games/${gameId}`);
            
            playerNumber = 1;
            
            const randomMap = maps[Math.floor(Math.random() * maps.length)];

            const initialGameData = {
                map: randomMap,
                players: {
                    1: { ...playerStartPositions[1], speed: 1, blastRange: 1 }
                },
                turn: 1,
                gameState: 'waiting'
            };
            
            try {
                await setDoc(gameRef, initialGameData);
                console.log("Game created with ID:", gameId);
                setupGameListener();
                startGameUI();
            } catch (error) {
                console.error("L·ªói khi t·∫°o game:", error);
            }
        });

        document.getElementById('joinGameBtn').addEventListener('click', async () => {
            const inputGameId = document.getElementById('gameIdInput').value;
            if (!inputGameId || !userId) return;

            gameId = inputGameId;
            gameRef = doc(db, 'artifacts', appId, 'public/data', `games/${gameId}`);
            
            const gameSnap = await getDoc(gameRef);
            if (gameSnap.exists() && !gameSnap.data().players[2]) {
                playerNumber = 2;
                await setDoc(gameRef, { players: { ...gameSnap.data().players, 2: { ...playerStartPositions[2], speed: 1, blastRange: 1 } }, gameState: 'playing' }, { merge: true });
                console.log("Joined game:", gameId);
                setupGameListener();
                startGameUI();
            } else {
                showMessage("L·ªói!", "Game kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ ƒë·∫ßy.");
            }
        });

        // Thi·∫øt l·∫≠p l·∫Øng nghe Firestore
        function setupGameListener() {
            onSnapshot(gameRef, (docSnap) => {
                if (docSnap.exists()) {
                    gameData = docSnap.data();
                    updateUI();
                }
            });
        }
        
        // Kh·ªüi ƒë·ªông UI tr√≤ ch∆°i
        function startGameUI() {
            document.getElementById('lobby').classList.add('hidden');
            document.getElementById('game-container').classList.remove('hidden');
            createGameBoard();
            document.addEventListener('keydown', handleKeydown);
        }

        // X·ª≠ l√Ω n√∫t ch∆°i l·∫°i trong h·ªôp th√¥ng b√°o
        document.getElementById('messageButton').addEventListener('click', () => {
             location.reload(); // T·∫£i l·∫°i trang ƒë·ªÉ b·∫Øt ƒë·∫ßu game m·ªõi
        });

        // Kh·ªüi t·∫°o Firebase khi trang t·∫£i
        window.onload = () => {
            initFirebase();
        };
    </script>
</body>
</html>
